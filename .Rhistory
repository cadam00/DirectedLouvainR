edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = "black",
vertex.label.cex = 0.8,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
set.seed(42)
part <- directed_louvain(el, verbose=FALSE)
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
# Find partitions
part <- directed_louvain(el, verbose=FALSE)
cat("Partitions:", part, "\n")
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
citation("igraph")
set.seed(42)
cat("Directed modularity:", Q, "\n")
set.seed(42)
# Find partitions
part <- directed_louvain(el, verbose=FALSE)
cat("Partitions:", part, "\n")
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
getwd()
plt.savefig("vignettes"/directedlouvain.png",bbox_inches='tight',pad_inches=0)
plt.savefig("vignettes/directedlouvain.png",bbox_inches='tight',pad_inches=0)
png("vignettes/directedlouvain.png")
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
dev.off()
img <- magick::image_read(out_file)
png("vignettes/directedlouvain.png")
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
dev.off()
img <- magick::image_read("vignettes/directedlouvain.png")
img_trimmed <- magick::image_trim(img)
magick::image_write(img_trimmed, "vignettes/directedlouvain.png")
library(igraph)
library(DirectedLouvainR)
library(igraph)
?png
png("vignettes/directedlouvain.png", res=600)
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
# Import packages
library(DirectedLouvainR)
library(igraph)
# Build a graph with 3 communities of different sizes.
# It could be an adjacency matrix or an igraph object instead of this edge list.
el <- data.frame(
from   = c(1,1,2,2,3,3,  4,4,5,5,6,6,  7,7,8,8,9,9,10,10,11,11,12,12),
to     = c(2,3,1,3,1,2,  5,6,4,6,4,5,  8,9,7,9,7,8,10,11,10,12,11,12),
weight = c(1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1)
)
# Add weaker inter-community edges
el <- rbind(el,
data.frame(from=c(3,6,9), to=c(4,7,1), weight=c(0.2,0.2,0.2)))
# Set seed for reproducibility
set.seed(42)
# Find partitions using Directional Louvain
part <- directed_louvain(el, verbose=FALSE)
cat("Partitions:", part, "\n")
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
png("vignettes/directedlouvain.png", res=600)
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
g
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
par(mar=c(1,1,1,1))
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
dev.off()
dev.off()
png("vignettes/directedlouvain.png", res=600)
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
dev.new()
dev.new()
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
img <- magick::image_read("vignettes/directedlouvain.png")
img_trimmed <- magick::image_trim(img)
magick::image_write(img_trimmed, "vignettes/directedlouvain.png")
withr::with_options(list(repos = c(CRAN = "https://cloud.r-project.org/")),
{callr::default_repos()
rcmdcheck::rcmdcheck(args = c("--no-manual", "--as-cran")) })
withr::with_options(list(repos = c(CRAN = "https://cloud.r-project.org/")),
{callr::default_repos()
rcmdcheck::rcmdcheck(args = c("--no-manual", "--as-cran")) })
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::build(manual=TRUE)
devtools::build(manual=TRUE)
devtools::build_manual()
devtools::check_mac_release()
withr::with_options(list(repos = c(CRAN = "https://cloud.r-project.org/")),
{callr::default_repos()
rcmdcheck::rcmdcheck(args = c("--no-manual", "--as-cran")) })
level
?switch
level = "final"
switch(level, final=-2, hierarchical=-1, level)
switch(-1, final=-2, hierarchical=-1, level)
switch("hierarchical", final=-2, hierarchical=-1, level)
switch(0, final=-2, hierarchical=-1, level)
level
level <- 0
level <- switch(level, final=-2, hierarchical=-1, level)
level
switch(level, final=-2, hierarchical=-1, level)
switch("x",
"1" = "Sunday",
"2" = "Monday",
"3" = "Tuesday",
"4" = "Wednesday",
"5" = "Thursday",
"6" = "Friday",
"7" = "Saturday",
stop("Invalid input")
)
level=0
switch(level, "final"=-2, "hierarchical"=-1, level)
levle
lvl <- switch(level, "final"=-2, "hierarchical"=-1, level)
lvl
level=0
switch(level, "final"=-2, "hierarchical"=-1, return(level))
lvl = switch(level, "final"=-2, "hierarchical"=-1, return(level))
lvl
lvl <- switch(level, "final"=-2, "hierarchical"=-1, level)
lvl
####################
level <- 0
lvl <- switch(level, "final"=-2, "hierarchical"=-1, level)
lvl
level <- 0
lvl <- switch(level, "final"=-2, "hierarchical"=-1, level)
lvl
level
lvl <- switch(level, "final"=-2, "hierarchical"=-1, as.character(level))
lvl
level <- 0
lvl <- switch(level, final=-2, hierarchical=-1, level)
lvl
switch(level,
final        = -2,
hierarchical = -1,
level)
switch(level,
final = -2,
hierarchical = -1,
level)
lvl <- switch(level, final=-2, hierarchical=-1, {level})
lvl
map_level <- function(level) {
switch(level,
final = -2,
hierarchical = -1,
{ level })   # braces force evaluation as default
}
map_level(level)
lvl = map_level(level)
lvl
el <- data.frame(
from   = c(1, 2, 3),
to     = c(2, 3, 1),
weight = c(1, 2, 3)
)
directed_louvain(el, level="hierarchical")
# Import packages
library(DirectedLouvainR)
library(igraph)
# Build a graph with 3 communities of different sizes.
# It could be an adjacency matrix or an igraph object instead of this edge list.
el <- data.frame(
from   = c(1,1,2,2,3,3,  4,4,5,5,6,6,  7,7,8,8,9,9,10,10,11,11,12,12),
to     = c(2,3,1,3,1,2,  5,6,4,6,4,5,  8,9,7,9,7,8,10,11,10,12,11,12),
weight = c(1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1)
)
# Add weaker inter-community edges
el <- rbind(el,
data.frame(from=c(3,6,9), to=c(4,7,1), weight=c(0.2,0.2,0.2)))
# Set seed for reproducibility
set.seed(42)
# Find partitions using Directional Louvain
part <- directed_louvain(el, verbose=FALSE)
cat("Partitions:", part, "\n")
el <- data.frame(
from   = c(1, 2, 3),
to     = c(2, 3, 1),
weight = c(1, 2, 3)
)
directed_louvain(el)
library(DirectedLouvainR)
library(igraph)
# Build a graph with 3 communities of different sizes.
# It could be an adjacency matrix or an igraph object instead of this edge list.
el <- data.frame(
from   = c(1,1,2,2,3,3,  4,4,5,5,6,6,  7,7,8,8,9,9,10,10,11,11,12,12),
to     = c(2,3,1,3,1,2,  5,6,4,6,4,5,  8,9,7,9,7,8,10,11,10,12,11,12),
weight = c(1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1)
)
# Add weaker inter-community edges
el <- rbind(el,
data.frame(from=c(3,6,9), to=c(4,7,1), weight=c(0.2,0.2,0.2)))
# Set seed for reproducibility
set.seed(42)
# Find partitions using Directional Louvain
part <- directed_louvain(el, verbose=FALSE)
cat("Partitions:", part, "\n")
library(DirectedLouvainR)
library(igraph)
# Build a graph with 3 communities of different sizes.
# It could be an adjacency matrix or an igraph object instead of this edge list.
el <- data.frame(
from   = c(1,1,2,2,3,3,  4,4,5,5,6,6,  7,7,8,8,9,9,10,10,11,11,12,12),
to     = c(2,3,1,3,1,2,  5,6,4,6,4,5,  8,9,7,9,7,8,10,11,10,12,11,12),
weight = c(1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1)
)
# Add weaker inter-community edges
el <- rbind(el,
data.frame(from=c(3,6,9), to=c(4,7,1), weight=c(0.2,0.2,0.2)))
# Set seed for reproducibility
set.seed(42)
# Find partitions using Directional Louvain
part <- directed_louvain(el, verbose=FALSE, level="final")
cat("Partitions:", part, "\n")
library(DirectedLouvainR)
library(igraph)
# Build a graph with 3 communities of different sizes.
# It could be an adjacency matrix or an igraph object instead of this edge list.
el <- data.frame(
from   = c(1,1,2,2,3,3,  4,4,5,5,6,6,  7,7,8,8,9,9,10,10,11,11,12,12),
to     = c(2,3,1,3,1,2,  5,6,4,6,4,5,  8,9,7,9,7,8,10,11,10,12,11,12),
weight = c(1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1)
)
# Add weaker inter-community edges
el <- rbind(el,
data.frame(from=c(3,6,9), to=c(4,7,1), weight=c(0.2,0.2,0.2)))
# Set seed for reproducibility
set.seed(42)
# Find partitions using Directional Louvain
part <- directed_louvain(el, verbose=FALSE, level=10)
cat("Partitions:", part, "\n")
library(DirectedLouvainR)
library(igraph)
# Build a graph with 3 communities of different sizes.
# It could be an adjacency matrix or an igraph object instead of this edge list.
el <- data.frame(
from   = c(1,1,2,2,3,3,  4,4,5,5,6,6,  7,7,8,8,9,9,10,10,11,11,12,12),
to     = c(2,3,1,3,1,2,  5,6,4,6,4,5,  8,9,7,9,7,8,10,11,10,12,11,12),
weight = c(1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1)
)
# Add weaker inter-community edges
el <- rbind(el,
data.frame(from=c(3,6,9), to=c(4,7,1), weight=c(0.2,0.2,0.2)))
# Set seed for reproducibility
set.seed(42)
# Find partitions using Directional Louvain
part <- directed_louvain(el, verbose=FALSE, level=100)
cat("Partitions:", part, "\n")
library(DirectedLouvainR)
library(igraph)
# Build a graph with 3 communities of different sizes.
# It could be an adjacency matrix or an igraph object instead of this edge list.
el <- data.frame(
from   = c(1,1,2,2,3,3,  4,4,5,5,6,6,  7,7,8,8,9,9,10,10,11,11,12,12),
to     = c(2,3,1,3,1,2,  5,6,4,6,4,5,  8,9,7,9,7,8,10,11,10,12,11,12),
weight = c(1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1)
)
# Add weaker inter-community edges
el <- rbind(el,
data.frame(from=c(3,6,9), to=c(4,7,1), weight=c(0.2,0.2,0.2)))
# Set seed for reproducibility
set.seed(42)
# Find partitions using Directional Louvain
part <- directed_louvain(el, verbose=FALSE)
cat("Partitions:", part, "\n")
`
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
dev.new()
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
img <- magick::image_read("vignettes/directedlouvain.png")
img_trimmed <- magick::image_trim(img)
magick::image_write(img_trimmed, "vignettes/directedlouvain.png")
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
set.seed(42)
# Find partitions using Directional Louvain
part <- directed_louvain(el, verbose=FALSE)
cat("Partitions:", part, "\n")
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
dev.new()
set.seed(42)
# Find partitions using Directional Louvain
part <- directed_louvain(el, verbose=FALSE)
cat("Partitions:", part, "\n")
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
img <- magick::image_read("vignettes/directedlouvain.png")
img_trimmed <- magick::image_trim(img)
magick::image_write(img_trimmed, "vignettes/directedlouvain.png")
?usethis::use_github_action_check_standard
use_github_actions()
usethis::use_github_actions()
?usethis::use_github_actions
usethis::use_github_action()
devtools::check_mac_release()
# Edge list as data.frame
el <- data.frame(
from   = c(1, 2, 3),
to     = c(2, 3, 1),
weight = c(1, 2, 3)
)
directed_louvain(el)
identical
R.version$compiler
R.version$platform
as.integer(NULL - 1)
is.null(as.integer(NULL - 1))
devtools::check_mac_release()
library(DirectedLouvainR)
el <- data.frame(from = c(1,2,3), to = c(2,3,1), weight = c(1,2,3))
directed_louvain(el)
citation("igraph")
usethis::use_pkgdown()
usethis::use_github(protocol = "https")
pkgdown::build_site()
pkgdown::build_site_github_pages()
usethis::use_github(private = FALSE)
usethis::use_git_remote("origin", url = NULL, overwrite = TRUE)
usethis::use_github(private = FALSE)
usethis::use_github_action("pkgdown")
usethis::use_pkgdown_github_pages()
