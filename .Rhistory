library(DirectedLouvainR)
# Edge list as data.frame
el <- data.frame(
from   = c(1, 2, 3),
to     = c(2, 3, 1),
weight = c(1, 2, 3)
)
directed_louvain(el)
# Edge list as data.frame
elc <- data.frame(
from   = c("A", "B", "C"),
to     = c("B", "C", "A"),
weight = c(1, 2, 3),
stringsAsFactors = FALSE
)
directed_louvain(elc)
# Adjacency matrix
adj <- matrix(c(0,1,0,
0,0,2,
3,0,0), nrow=3, byrow=TRUE)
rownames(adj) <- c("x","y","z")
colnames(adj) <- c("z","x","y")  # deliberately permuted
directed_louvain(adj)   # columns realigned to row order
library(igraph)
g <- make_ring(4)
E(g)$weight <- c(1,2,3,4)
V(g)$name <- c("n1","n2","n3","n4")
directed_louvain(g)
part <- c(x=1, y=1, z=2)
directed_modularity(adj, part)
directed_louvain(g, verbose=TRUE)
class(igraph)
class(g)
# Edge list as data.frame
el <- data.frame(
from   = c(1, 2, 3),
to     = c(2, 3, 1),
weight = c(1, 2, 3)
)
part <- directed_louvain(el)
directed_modularity(part)
directed_modularity(el, part)
# Edge list as data.frame
elc <- data.frame(
from   = c("A", "B", "C"),
to     = c("B", "C", "A"),
weight = c(1, 2, 3),
stringsAsFactors = FALSE
)
directed_louvain(elc, part)
part <- directed_louvain(elc)
directed_modularity(elc, part)
part
# Adjacency matrix
adj <- matrix(c(0,1,0,
0,0,2,
3,0,0), nrow=3, byrow=TRUE)
rownames(adj) <- c("x","y","z")
colnames(adj) <- c("z","x","y")  # deliberately permuted
part <- directed_louvain(adj)   # columns realigned to row order
directed_modularity(elc, part)
directed_modularity(adj, part)
# igraph
library(igraph)
g <- make_ring(4)
E(g)$weight <- c(1,2,3,4)
V(g)$name <- c("n1","n2","n3","n4")
directed_louvain(g)
directed_modularity(g, part)
part <- directed_louvain(g)
directed_modularity(g, part)
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
##############
el <- data.frame(
from   = c(1, 2, 3, 4, 2),
to     = c(2, 1, 4, 3, 3),
weight = c(1, 0.5, 1, 0.5, 0.1))
set.seed(42)
# Partition A: {1,2}, {3,4}
part <- directed_louvain(el, verbose=FALSE)
directed_modularity(el, part)
library(igraph)
g <- graph_from_edgelist(as.matrix(el[,c("from", "to")]), directed = TRUE)
E(g)$weight <- el$weight
V(g)$color <- ifelse(partA == 1, "lightblue", "orange")
##############
el <- data.frame(
from   = c(1, 2, 3, 4, 2),
to     = c(2, 1, 4, 3, 3),
weight = c(1, 0.5, 1, 0.5, 0.1))
set.seed(42)
# Partition A: {1,2}, {3,4}
part <- directed_louvain(el, verbose=FALSE)
directed_modularity(el, part)
library(igraph)
g <- graph_from_edgelist(as.matrix(el[,c("from", "to")]), directed = TRUE)
E(g)$weight <- el$weight
V(g)$color <- ifelse(part == 1, "lightblue", "orange")
plot(g,
edge.width=E(g)$weight * 5, # make connection weight lines thicker,
edge.curved = rep(0.4, ecount(g)) # make directions more visible
)
library(igraph)
library(DirectedLouvainR)
# Build a graph with 3 communities of different sizes
el <- data.frame(
from   = c(1,1,2,2,3,3,  4,4,5,5,6,6,  7,7,8,8,9,9,10,10,11,11,12,12),
to     = c(2,3,1,3,1,2,  5,6,4,6,4,5,  8,9,7,9,7,8,10,11,10,12,11,12),
weight = c(1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1)
)
# Add weaker inter-community edges
el <- rbind(el,
data.frame(from=c(3,6,9), to=c(4,7,1), weight=c(0.2,0.2,0.2)))
set.seed(123)
part <- directed_louvain(el, verbose=FALSE)
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
# Visualize
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
cols <- rainbow(max(part))
V(g)$color <- cols[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.cex = 0.8,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
set.seed(42)
part <- directed_louvain(el, verbose=FALSE)
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
cols <- rainbow(max(part))
V(g)$color <- cols[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.cex = 0.8,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
max(part)
cols[part]
part
rainbow(max(part))[part]
set.seed(42)
part <- directed_louvain(el, verbose=FALSE)
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- rainbow(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.cex = 0.8,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.cex = 0.8,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.color = 1,
vertex.label.cex = 0.8,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = 1,
vertex.label.cex = 0.8,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = 0,
vertex.label.cex = 0.8,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = 3,
vertex.label.cex = 0.8,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
set.seed(42)
part <- directed_louvain(el, verbose=FALSE)
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = "black",
vertex.label.cex = 0.8,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
set.seed(42)
part <- directed_louvain(el, verbose=FALSE)
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
# Find partitions
part <- directed_louvain(el, verbose=FALSE)
cat("Partitions:", part, "\n")
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
citation("igraph")
set.seed(42)
cat("Directed modularity:", Q, "\n")
set.seed(42)
# Find partitions
part <- directed_louvain(el, verbose=FALSE)
cat("Partitions:", part, "\n")
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
getwd()
plt.savefig("vignettes"/directedlouvain.png",bbox_inches='tight',pad_inches=0)
plt.savefig("vignettes/directedlouvain.png",bbox_inches='tight',pad_inches=0)
png("vignettes/directedlouvain.png")
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
dev.off()
img <- magick::image_read(out_file)
png("vignettes/directedlouvain.png")
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
dev.off()
img <- magick::image_read("vignettes/directedlouvain.png")
img_trimmed <- magick::image_trim(img)
magick::image_write(img_trimmed, "vignettes/directedlouvain.png")
library(igraph)
library(DirectedLouvainR)
library(igraph)
?png
png("vignettes/directedlouvain.png", res=600)
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
# Import packages
library(DirectedLouvainR)
library(igraph)
# Build a graph with 3 communities of different sizes.
# It could be an adjacency matrix or an igraph object instead of this edge list.
el <- data.frame(
from   = c(1,1,2,2,3,3,  4,4,5,5,6,6,  7,7,8,8,9,9,10,10,11,11,12,12),
to     = c(2,3,1,3,1,2,  5,6,4,6,4,5,  8,9,7,9,7,8,10,11,10,12,11,12),
weight = c(1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1)
)
# Add weaker inter-community edges
el <- rbind(el,
data.frame(from=c(3,6,9), to=c(4,7,1), weight=c(0.2,0.2,0.2)))
# Set seed for reproducibility
set.seed(42)
# Find partitions using Directional Louvain
part <- directed_louvain(el, verbose=FALSE)
cat("Partitions:", part, "\n")
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
png("vignettes/directedlouvain.png", res=600)
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
# Plot
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
V(g)$color <- topo.colors(max(part))[part]
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
g
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
par(mar=c(1,1,1,1))
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
dev.off()
dev.off()
png("vignettes/directedlouvain.png", res=600)
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
dev.new()
dev.new()
plot(g,
edge.width = E(g)$weight * 3,
edge.curved = rep(0.3, ecount(g)),
vertex.size = 25,
#vertex.label.color = "black",
vertex.label.cex = 1,
main = paste("Directed Louvain communities, Q =", round(Q,3))
)
img <- magick::image_read("vignettes/directedlouvain.png")
img_trimmed <- magick::image_trim(img)
magick::image_write(img_trimmed, "vignettes/directedlouvain.png")
withr::with_options(list(repos = c(CRAN = "https://cloud.r-project.org/")),
{callr::default_repos()
rcmdcheck::rcmdcheck(args = c("--no-manual", "--as-cran")) })
withr::with_options(list(repos = c(CRAN = "https://cloud.r-project.org/")),
{callr::default_repos()
rcmdcheck::rcmdcheck(args = c("--no-manual", "--as-cran")) })
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::build(manual=TRUE)
devtools::build(manual=TRUE)
devtools::build_manual()
devtools::check_mac_release()
withr::with_options(list(repos = c(CRAN = "https://cloud.r-project.org/")),
{callr::default_repos()
rcmdcheck::rcmdcheck(args = c("--no-manual", "--as-cran")) })
level
?switch
level = "final"
switch(level, final=-2, hierarchical=-1, level)
switch(-1, final=-2, hierarchical=-1, level)
switch("hierarchical", final=-2, hierarchical=-1, level)
switch(0, final=-2, hierarchical=-1, level)
level
level <- 0
level <- switch(level, final=-2, hierarchical=-1, level)
level
switch(level, final=-2, hierarchical=-1, level)
switch("x",
"1" = "Sunday",
"2" = "Monday",
"3" = "Tuesday",
"4" = "Wednesday",
"5" = "Thursday",
"6" = "Friday",
"7" = "Saturday",
stop("Invalid input")
)
level=0
switch(level, "final"=-2, "hierarchical"=-1, level)
levle
lvl <- switch(level, "final"=-2, "hierarchical"=-1, level)
lvl
level=0
switch(level, "final"=-2, "hierarchical"=-1, return(level))
lvl = switch(level, "final"=-2, "hierarchical"=-1, return(level))
lvl
lvl <- switch(level, "final"=-2, "hierarchical"=-1, level)
lvl
####################
level <- 0
lvl <- switch(level, "final"=-2, "hierarchical"=-1, level)
lvl
level <- 0
lvl <- switch(level, "final"=-2, "hierarchical"=-1, level)
lvl
level
lvl <- switch(level, "final"=-2, "hierarchical"=-1, as.character(level))
lvl
level <- 0
lvl <- switch(level, final=-2, hierarchical=-1, level)
lvl
switch(level,
final        = -2,
hierarchical = -1,
level)
switch(level,
final = -2,
hierarchical = -1,
level)
lvl <- switch(level, final=-2, hierarchical=-1, {level})
lvl
map_level <- function(level) {
switch(level,
final = -2,
hierarchical = -1,
{ level })   # braces force evaluation as default
}
map_level(level)
lvl = map_level(level)
lvl
el <- data.frame(
from   = c(1, 2, 3),
to     = c(2, 3, 1),
weight = c(1, 2, 3)
)
directed_louvain(el, level="hierarchical")
