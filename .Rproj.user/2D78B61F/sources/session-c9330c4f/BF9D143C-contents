img <- magick::image_read("vignettes/directedlouvain.png")
img_trimmed <- magick::image_trim(img)
magick::image_write(img_trimmed, "vignettes/directedlouvain.png")

##############
el <- data.frame(
  from   = c(1, 2, 3, 4, 2),
  to     = c(2, 1, 4, 3, 3),
  weight = c(1, 0.5, 1, 0.5, 0.1))

set.seed(42)
# Partition A: {1,2}, {3,4}
part <- directed_louvain(el, verbose=FALSE)
directed_modularity(el, part)

library(igraph)
g <- graph_from_edgelist(as.matrix(el[,c("from", "to")]), directed = TRUE)
E(g)$weight <- el$weight
V(g)$color <- ifelse(part == 1, "lightblue", "orange")

plot(g,
     edge.width=E(g)$weight * 5, # make connection weight lines thicker,
     edge.curved = rep(0.4, ecount(g)) # make directions more visible
)

###########
library(igraph)
library(DirectedLouvainR)

# Build a graph with 3 communities of different sizes
el <- data.frame(
  from   = c(1,1,2,2,3,3,  4,4,5,5,6,6,  7,7,8,8,9,9,10,10,11,11,12,12),
  to     = c(2,3,1,3,1,2,  5,6,4,6,4,5,  8,9,7,9,7,8,10,11,10,12,11,12),
  weight = c(1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1,  1,1,1,1,1,1)
)

# Add weaker inter-community edges
el <- rbind(el,
            data.frame(from=c(3,6,9), to=c(4,7,1), weight=c(0.2,0.2,0.2)))

set.seed(123)
part <- directed_louvain(el, verbose=FALSE)
Q <- directed_modularity(el, part)
cat("Directed modularity:", Q, "\n")

# Visualize
g <- graph_from_edgelist(as.matrix(el[,c("from","to")]), directed=TRUE)
E(g)$weight <- el$weight
cols <- rainbow(max(part))
V(g)$color <- cols[part]

plot(g,
     edge.width = E(g)$weight * 3,
     edge.curved = rep(0.3, ecount(g)),
     vertex.size = 25,
     vertex.label.cex = 0.8,
     main = paste("Directed Louvain communities, Q =", round(Q,3))
)

####################
level <- 0
lvl <- if (level == "final") final=-2, hierarchical=-1, {level})
lvl
